## 设计学习模式（四） ##

> 下面所学的模式是结构型模式

#### 外观模式 ####

&emsp;** 意图： **为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

&emsp;** 主要解决： **降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。

&emsp;** 何时使用： **1、客户端不需要知道系统内部的复杂联系，整个系统只需要提供一个“接待员”即可。 2、定义系统的入口。

&emsp;** 如何解决： **客户端不与系统耦合，外观类与系统耦合。

&emsp;<img src="./facade_pattern_uml_diagram.jpg" alt="外观模式类图" width="600px"/>

&emsp;本模式的样例就是本文件夹下的FacadePattern工程

** /\*\*---------------------- 来自包子的分享 ----------------------\*\*/**
电脑整机是CPU、内存、硬盘的外观。有了外观以后，启动电脑和关闭电脑都简化了。直接new一个电脑。
在new电脑的同时把cpu、内存、硬盘都初始化好并且接好线。
对外暴露方法（启动电脑、关闭电脑）。
启动电脑（按一下电源键）：启动CPU、启动内存、启动硬盘。
关闭电脑（按一下电源键）：关闭硬盘、关闭内存、关闭CPU。
** 更过参考内容 **
- <a href="http://www.runoob.com/w3cnote/facade-pattern-2.html">Java设计模式——外观模式</a>
- <a href="http://www.runoob.com/w3cnote/facade-pattern-3.html">Java设计模式之门面模式-医院实例</a>
** /\*\*---------------------- 来自包子的分享结束 ----------------------\*\*/**

#### 享元模式 ####

&emsp;** 意图： **运用共享技术有效地支持大量细粒度的对象。

&emsp;** 主要解决： **在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。

&emsp;** 何时使用： **1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来替代。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。

&emsp;** 如何解决： **用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。

&emsp;<img src="./flyweight_pattern_uml_diagram.jpg" alt="享元模式类图" width="600px"/>

&emsp;本模式的样例是本文件夹下的FlyweightPattern工程。

#### 代理模式 ####

&emsp;** 意图： **为其他对象提供一种代理以控制对这个对象的访问。

&emsp;** 主要解决： **在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。

&emsp;**何时使用：**想在访问一个类是做一些控制。

&emsp;**如何解决：**增加中间层。

&emsp;<img src="./proxy_pattern_uml_diagram.jpg" alt="代理模式类图" width="600px"/>

&emsp;本模式的样例是本文件夹下的ProxyPattern工程。

