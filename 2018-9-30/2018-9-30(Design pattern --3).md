## 设计模式学习（三） ##

> 下面所学习的模式是结构型模式

#### 桥接模式 ####

&emsp;** 意图： **将抽象部分与实现部分分离，使他们都可以独立的变化。

&emsp;** 主要解决： **在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。

&emsp;** 何时使用： **实现系统可能有多个角度分类，每一种角度都可能变化。

&emsp;** 如何解决： **把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。

&emsp;<img src="./bridge_pattern_uml_diagram.jpg" alt="桥接模式类图" width="500px" />

&emsp;本模式的样例是本文件夹下的BridgePattern工程

** /\*\*------------------------- 来自jade的分享 -------------------------\*\*/ **  
桥接模式：Bridge Pattern  
将抽象和实现放在两个不同的类层次中，使它们可以独立的变化。————《Head First 设计模式》  
** 将类的功能层次结构和实现层次结构相分离，使二者能够独立的变化，并在两者之间搭建桥梁，实现桥接。———— 《图解设计模式》 **  
类的功能层次结构：父类具有基本功能，在子类中增加新的功能；    
类的实现层次结构：父类通过声明抽象方法来定义接口，子类通过实现具体方法来实现接口。  
桥接模式中有四个角色：  
** 抽象化角色： **使用实现者角色提供的接口来定义基本功能接口。  
持有实现者角色，并在功能接口中委托给它，起到搭建桥梁的作用；  
注意，抽象化角色并不是指它就是一个抽象类，而是指抽象了实现。  
** 改善后的抽象化角色： **作为抽象化角色的子类，增加新的功能，也就是增加新的接口（方法）；与其构成类的功能层次结构；  
** 实现者角色： **提供了用于抽象化角色的借口；它是一个抽象类或者接口。  
** 具体的实现者角色： **作为实现者角色的子类，通过实现具体方法来实现接口；与其构成类的实现层次结构。  
如果抽象和实现两者做不到独立的变化，就不算桥接模式。  
** /\*\*------------------------- 来自jade的分享结束 -------------------------\*\*/ **  

#### 过滤器模式 ####

&emsp;<img src="./filter_pattern_uml_diagram.jpg" alt="过滤器模式类图" width="500px"/>

&emsp;本模式的样例是本文件夹下的CriteriaPattern工程

#### 组合模式 ####

&emsp;** 意图： **将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

&emsp;** 主要解决： **它在我们树形结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。

&emsp;** 何时使用： **1、你想表示对象的部分-整体层次结构（树形结构）。2、你希望用户忽略组合对象与单个对象的不同，用户将统一的使用组合结构中的所有对象。

&emsp;** 如何解决： **树枝和叶子实现统一接口，树枝内部组合该接口。

&emsp;<img src="./composite_pattern_uml_diagram.jpg" alt="组合模式类图" width="500px"/>

&emsp;本模式的样例是本文件夹下的CompositePattern工程

** /\*\*---------------------- 来自渔童的分享 ----------------------\*\*/ **  
1、组合模式，就是在一个对象中包含其他对象，这些被包含的对象可能是终点对象（不在包含别的对象），也有可能是非终点对象（其内部还包括其他对象，或叫组对象），我们将对象称为节点，即一个根节点包括许多子节点，这些子节点有的不再包含子节点，而有的仍然包含子节点，以此类推。  

2、所谓组合模式，其实说的是对象包含对象的问题，通过组合的方式（在对象内部引用对象）来进行布局，我们认为这种组合是区别于继承的，而另一层含义是指树形结构子节点的抽象（将叶子节点与树枝节点抽象为子节点），区别于普通的分别定义叶子节点与树枝节点的方式。  
** /\*\*---------------------- 来自渔童的分享结束 ----------------------\*\*/ **  

#### 装饰器模式 ####

&emsp;** 意图： **动态的给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。

&emsp;** 主要解决： **一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为了引入静态特征，并且随着扩展功能的增多，子类会很膨胀。

&emsp;** 何时使用： **在不想增加很多子类的情况下扩展类。

&emsp;** 如何解决： **将具体功能职责划分，同时继承装饰者模式。

&emsp;<img src="./decorator_pattern_uml_diagram.jpg" alt="装饰器模式类图" width="500px"/>

&emsp;本模式的样例是本文件夹下的DecoratorPattern工程

** /\*\*------------------------ 来自周霆的分享 ------------------------\*\*/ **
> 装饰模式为已有类动态附加额外的功能就像LOL、王者荣耀等类Dota游戏中，英雄升级一样。每次英雄升级都会附加一个额外技能点学习技能。具体的英雄就是ConcreteComponent，技能栏就是装饰器Decorator，每个技能就是ConcreteDecorator；

** 样例是本文件夹下的ZTDecoratorPattern工程 **

** /\*\*------------------------ 来自周霆的分享结束 ------------------------\*\*/ **