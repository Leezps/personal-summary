## 设计模式学习（五） ##

> 以下所学模式是行为型模式

#### 责任链模式 ####

&emsp;** 意图： **避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

&emsp;** 主要解决： **职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无需关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。

&emsp;** 何时使用： **在处理消息的时候以过滤很多道。

&emsp;** 如何解决： **拦截的类都实现统一接口。

&emsp;<img src="./chain_pattern_uml_diagram.jpg" alt="责任链模式的类图" width="600px"/>

&emsp;本模式的样例是本文件夹下的ChainOfResponsibilityPattern工程

#### 命令模式 ####

&emsp;** 意图： **将一个请求封装成一个对象，从而使你可以用不同的请求对客户进行参数化。

&emsp;** 主要解决： **在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。

&emsp;** 何时使用： **在某些场合，比如要对行为进行“记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合

&emsp;** 如何解决： **通过调用者调用接受者执行命令，顺序：调用者->接受者->命令。

&emsp;<img src="./command_pattern_uml_diagram.jpg" alt="命令模式的类图" width="600px"/>

&emsp;本模式的样例是本文件夹下的CommandPattern工程

#### 解释器模式 ####

&emsp;** 意图： **给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识解释语言中的句子。

&emsp;** 主要解决： **对于一些固定文法构建一个解释句子的解释器。

&emsp;** 何时使用： **如果一种特定类型的问题发生的频率足够高，那么可能就只得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些巨资来解决该问题。

&emsp;** 如何解决： **构建语法树，定义终结符与非终结符。

&emsp;<img src="./interpreter_pattern_uml_diagram.jpg" alt="解释器模式的类图" width="600px"/>

&emsp;本模式的样例是本文件夹下的InterpreterPattern工程

#### 迭代器模式 ####

&emsp;** 意图： **提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。

&emsp;** 主要解决： **不同的方式来遍历整个整合对象。

&emsp;** 何时使用： **遍历一个聚合对象。

&emsp;** 如何解决： **把在元素之间游走的责任交给迭代器，而不是聚合对象。

&emsp;<img src="./iterator_pattern_uml_diagram.jpg" alt="迭代器模式的类图" width="600px"/>

&emsp;本模式的样例是本文件夹下的IteratorPattern工程。